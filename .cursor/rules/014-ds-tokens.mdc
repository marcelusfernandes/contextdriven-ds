---
description: Design System Tokens - Applies to tokens.ts and all files that use design tokens for consistent theming and styling
alwaysApply: true
---
# Design System Tokens - Uso Pr√°tico

Este documento define como **USAR** tokens no sistema.

> **üìê ARQUITETURA:** Para entender a estrutura de 3 camadas (Primitive ‚Üí Semantic ‚Üí Component),  
> consulte `015-ds-tokens-architecture.mdc` **PRIMEIRO**.

## O que s√£o Design Tokens?

Design tokens s√£o **valores nomeados** que representam decis√µes de design visual:
- Cores
- Espa√ßamentos
- Tipografia
- Sombras
- Raios de borda
- Dura√ß√µes de anima√ß√£o

**Benef√≠cios:**
- Consist√™ncia visual em todo o sistema
- Manuten√ß√£o centralizada
- Themes (light/dark) autom√°ticos
- Altera√ß√µes propagam automaticamente

## Estrutura de Tokens

### Arquivo Principal: `tokens.ts`

O Design System usa **arquitetura de 3 camadas**:

```typescript
// ================================================================================
// CAMADA 1: PRIMITIVE (valores raw)
// ================================================================================
const primitive = {
  color: {
    zeYellow: '#ffcc00',
    gray800: '#333333',
    // ...
  },
  space: { 0: 0, 4: 4, 8: 8, /* ... */ },
  // ...
} as const

// ================================================================================
// CAMADA 2: SEMANTIC (inten√ß√£o e contexto)
// ================================================================================
const semantic = {
  color: {
    brand: {
      primary: ref(primitive.color.zeYellow),
      primaryHover: ref(primitive.color.zeYellowDark),
    },
    text: {
      primary: ref(primitive.color.gray800),
    },
  },
  spacing: {
    component: {
      gapSmall: ref(primitive.space[8]),
    },
  },
} as const

// ================================================================================
// CAMADA 3: COMPONENT (aplica√ß√£o espec√≠fica)
// ================================================================================
export const tokens = {
  // ‚úÖ Expor semantic para casos avan√ßados
  semantic: semantic,
  
  // ‚úÖ Tokens de componentes
  button: {
    variant: {
      primary: {
        normal: {
          bg: ref(semantic.color.brand.primary),
        }
      }
    }
  }
} as const
```

**üìö Detalhes completos:** Ver `015-ds-tokens-architecture.mdc`

## Usando Tokens em Componentes

### Em Componentes do Design System

**‚úÖ Usar component tokens:**

```typescript
import { tokens } from '@/tokens'

// ‚úÖ DO - Usar tokens de componentes
export const Button = styled(Stack, {
  // Component tokens j√° tem todos os valores necess√°rios
  backgroundColor: tokens.button.variant.primary.normal.bg,
  padding: tokens.button.size.medium.paddingVertical,
  borderRadius: tokens.button.size.medium.borderRadius,
})
```

**‚ö†Ô∏è Casos espec√≠ficos (semantic tokens):**

```typescript
// Quando o component token n√£o existe ainda
export const CustomComponent = styled(Stack, {
  backgroundColor: tokens.semantic.color.brand.primary,
  padding: tokens.semantic.spacing.component.paddingMedium,
})
```

**‚ùå NUNCA hardcode valores:**

```typescript
// ‚ùå DON'T
export const Button = styled(Stack, {
  backgroundColor: '#ffcc00',   // ‚ùå Magic color
  padding: 12,                  // ‚ùå Magic number
})
```

### Em Props de Componentes

```typescript
// ‚úÖ DO - Passar valores via tokens
<CustomStack
  backgroundColor={tokens.semantic.color.surface.primary}
  padding={tokens.semantic.spacing.component.paddingMedium}
/>

// ‚ùå DON'T - Hardcode
<CustomStack
  backgroundColor="#ffffff"
  padding={16}
/>
```

### Acessar Valores Diretamente (Casos Raros)

```typescript
import { tokens } from '@/tokens'

// ‚úÖ Usar semantic quando necess√°rio
const primaryColor = tokens.semantic.color.brand.primary  // '#ffcc00'
const spacing = tokens.semantic.spacing.component.gapMedium  // 12

// ‚ö†Ô∏è Usar primitive APENAS em casos muito espec√≠ficos
import { primitive } from '@/tokens'
const rawYellow = primitive.color.zeYellow  // '#ffcc00'
```

## Nomenclatura de Tokens (Por Camada)

### PRIMITIVE Tokens

**Caracter√≠sticas:** Nomes descritivos, indicam o valor

```typescript
// ‚úÖ DO - Nomes descritivos
primitive.color.zeYellow          // Nome da marca + cor
primitive.color.gray800           // Fam√≠lia + peso/escala
primitive.color.successGreen      // Prop√≥sito + cor
primitive.color.blackAlpha50      // Cor + tipo + opacidade

// ‚ùå DON'T - Nomes gen√©ricos ou sem√¢nticos
primitive.color.primary           // ‚ùå Isso √© semantic!
primitive.color.buttonColor       // ‚ùå Isso √© component!
```

### SEMANTIC Tokens

**Caracter√≠sticas:** Nomes por inten√ß√£o/contexto de uso

```typescript
// ‚úÖ DO - Nomes por prop√≥sito/contexto
semantic.color.brand.primary        // Identidade da marca
semantic.color.text.secondary       // Hierarquia de texto
semantic.color.feedback.error       // Status/feedback
semantic.color.surface.overlay      // Tipo de superf√≠cie
semantic.spacing.component.gap      // Prop√≥sito do espa√ßamento

// ‚ùå DON'T - Nomes baseados em valores
semantic.color.yellow500            // ‚ùå Isso √© primitive!
semantic.color.big                  // ‚ùå Vago, sem contexto
semantic.spacing.pixels16           // ‚ùå Baseado em implementa√ß√£o
```

### COMPONENT Tokens

**Caracter√≠sticas:** Hierarquia clara (component ‚Üí property ‚Üí variant ‚Üí state)

```typescript
// ‚úÖ DO - Hierarquia clara
tokens.button.size.small.height
tokens.button.variant.primary.normal.bg
tokens.checkbox.state.error.hover.textColor
tokens.icon.size.medium

// ‚ùå DON'T - Estrutura flat ou inconsistente
tokens.buttonSmallHeight           // ‚ùå Sem hierarquia
tokens.primaryButtonBg             // ‚ùå Ordem errada
tokens.button.normalPrimaryBg      // ‚ùå Hierarquia invertida
```

## Themes

### Definindo Themes (em tamagui.config.ts)

**‚úÖ Usar semantic tokens:**

```typescript
import { createTamagui, createTokens } from '@tamagui/core'
import { tokens } from './tokens'

// Mapear semantic tokens para Tamagui
const tamaguiTokens = createTokens({
  color: {
    // ‚úÖ Usar semantic.color, n√£o primitivos!
    primary: tokens.semantic.color.brand.primary,
    secondary: tokens.semantic.color.brand.secondary,
    background: tokens.semantic.color.surface.primary,
    text: tokens.semantic.color.text.primary,
    border: tokens.semantic.color.border.default,
    // ...
  },
  space: {
    1: tokens.semantic.spacing.component.gapSmall,
    2: tokens.semantic.spacing.component.gapMedium,
    3: tokens.semantic.spacing.component.gapLarge,
    // ...
  },
})

export default createTamagui({
  tokens: tamaguiTokens,
  
  themes: {
    light: {
      background: tokens.semantic.color.surface.primary,
      foreground: tokens.semantic.color.text.primary,
      primary: tokens.semantic.color.brand.primary,
      border: tokens.semantic.color.border.default,
    },
    
    dark: {
      background: tokens.semantic.color.surface.tertiary,
      foreground: tokens.semantic.color.text.inverse,
      primary: tokens.semantic.color.brand.primary,
      border: tokens.semantic.color.border.strong,
    },
  },
})
```

### Usando Themes

```typescript
import { Theme } from '@tamagui/core'

// Aplicar theme espec√≠fico
<Theme name="dark">
  <Card />
</Theme>

// Inverter theme atual
<Theme inverse>
  <Card />
</Theme>

// ‚ö†Ô∏è NOTA: Componentes do DS N√ÉO usam $ prefix diretamente
// Eles usam tokens de componentes que resolvem para valores finais
export const Card = styled(Stack, {
  backgroundColor: tokens.semantic.color.surface.primary,  // ‚úÖ N√£o usa $
  color: tokens.semantic.color.text.primary,
  borderColor: tokens.semantic.color.border.default,
})
```

## Token Variants

### Varia√ß√µes de Cor

Para hover, pressed, etc:

```typescript
color: {
  primary: '#007AFF',
  primaryDark: '#0051D5',     // Hover
  primaryDarker: '#003D9F',   // Pressed
  primaryLight: '#4DA1FF',    // Light variant
  primaryLighter: '#99CCFF',  // Lighter variant
}
```

**Uso:**

```typescript
export const Button = styled(Stack, {
  backgroundColor: '$primary',
  
  hoverStyle: {
    backgroundColor: '$primaryDark',
  },
  
  pressStyle: {
    backgroundColor: '$primaryDarker',
  },
})
```

## Tokens Responsivos

### Media Queries com Tokens

```typescript
export const Container = styled(Stack, {
  padding: '$3',           // Mobile
  
  $gtSm: {
    padding: '$4',         // Tablet
  },
  
  $gtMd: {
    padding: '$6',         // Desktop
  },
})
```

### Tokens Diferentes por Breakpoint

```typescript
// tokens.ts
export const tokens = createTokens({
  space: {
    // Mobile-first
    containerPadding: 16,
    
    // Tablet
    '$gtSm': {
      containerPadding: 24,
    },
    
    // Desktop
    '$gtMd': {
      containerPadding: 32,
    },
  },
})
```

## Valida√ß√£o de Tokens

### TypeScript Type Safety

```typescript
import type { Tokens } from '@tamagui/core'

// Tokens s√£o tipados
const validToken: Tokens['color'] = '$primary'      // ‚úÖ OK
const invalidToken: Tokens['color'] = '$notExists' // ‚ùå Error
```

### Runtime Validation

```typescript
// Verificar se token existe
const isValidToken = (token: string): boolean => {
  return token in tokens.color
}

// Fallback para token inv√°lido
const getColor = (token: string): string => {
  return tokens.color[token] ?? tokens.color.primary
}
```

## Best Practices

### 1. Sempre Use Tokens (Nunca Hardcode)

```typescript
// ‚úÖ DO - Usar tokens
backgroundColor: tokens.semantic.color.brand.primary
padding: tokens.semantic.spacing.component.paddingMedium
borderRadius: tokens.semantic.radius.component.medium

// ‚ùå DON'T - Hardcode valores
backgroundColor: '#ffcc00'
padding: 12
borderRadius: 16
```

### 2. Respeite a Hierarquia de Camadas

```typescript
// ‚úÖ DO - Component usa Semantic
button: {
  variant: {
    primary: {
      normal: {
        bg: ref(semantic.color.brand.primary),  // ‚úÖ SEMANTIC
      }
    }
  }
}

// ‚ùå DON'T - Component usa Primitive direto
button: {
  variant: {
    primary: {
      normal: {
        bg: ref(primitive.color.zeYellow),  // ‚ùå Pula semantic!
      }
    }
  }
}
```

### 3. Sempre Use `ref()` para Rastreabilidade

```typescript
// ‚úÖ DO - Usar ref()
bg: ref(semantic.color.brand.primary),
padding: ref(semantic.spacing.component.paddingMedium),

// ‚ùå DON'T - Valores diretos perdem rastreabilidade
bg: semantic.color.brand.primary,
padding: semantic.spacing.component.paddingMedium,
```

### 4. N√£o Expor Primitivos no Export

```typescript
// ‚úÖ DO
export const tokens = {
  semantic: semantic,     // ‚úÖ Para casos avan√ßados
  button: {...},          // ‚úÖ Component tokens
}

// ‚ùå DON'T
export const tokens = {
  color: primitive.color,  // ‚ùå NUNCA expor primitivos!
  space: primitive.space,
}
```

### 5. Prefira Component Tokens em Componentes

```typescript
// ‚úÖ DO - Usar component tokens quando existem
export const Button = styled(Stack, {
  backgroundColor: tokens.button.variant.primary.normal.bg,
})

// ‚ö†Ô∏è ACEIT√ÅVEL - Usar semantic quando component n√£o existe
export const NewComponent = styled(Stack, {
  backgroundColor: tokens.semantic.color.brand.primary,
})

// ‚ùå DON'T - Pular component tokens que existem
export const Button = styled(Stack, {
  backgroundColor: tokens.semantic.color.brand.primary,  // Deveria usar button.variant!
})
```

## Migra√ß√£o de Valores Hardcoded

### Processo

1. **Identificar valores hardcoded:**
   ```typescript
   // Encontrar
   backgroundColor: '#007AFF'
   padding: 12
   ```

2. **Verificar se token existe:**
   ```typescript
   // Consultar tokens.ts
   color.primary: '#007AFF'  // ‚úÖ Existe
   space[3]: 12              // ‚úÖ Existe
   ```

3. **Substituir por token:**
   ```typescript
   backgroundColor: '$primary'
   padding: '$3'
   ```

4. **Criar token se n√£o existir:**
   ```typescript
   // Se n√£o existir token adequado, adicionar ao tokens.ts
   color: {
     // ...
     brandPurple: '#5856D6',  // Novo token
   }
   ```

## Enforcement (Code Review Checklist)

### Em tokens.ts

- [ ] Primitivos N√ÉO est√£o expostos no export principal
- [ ] Semantic referencia APENAS primitive
- [ ] Component referencia APENAS semantic (nunca primitive)
- [ ] Todos os valores usam `ref()`
- [ ] Zero valores hardcoded
- [ ] `as const` em todas as camadas
- [ ] TypeScript types exportados

### Em Componentes

- [ ] Nenhum valor hardcoded (cores, spacing, etc)
- [ ] Todos os valores v√™m de tokens
- [ ] Prefer√™ncia por component tokens quando existem
- [ ] Uso de semantic tokens quando component n√£o existe
- [ ] NUNCA tentar acessar primitive direto (n√£o est√° exposto)

### Em tamagui.config.ts

- [ ] createTokens() usa semantic tokens, n√£o primitivos
- [ ] Themes usam semantic tokens
- [ ] Mapeamento claro de DS tokens ‚Üí Tamagui tokens

### Arquitetura

- [ ] Respeita hierarquia: Primitive ‚Üí Semantic ‚Üí Component
- [ ] Sem quebra de camadas (component n√£o referencia primitive)
- [ ] Documenta√ß√£o inline clara
- [ ] Nomenclatura consistente por camada

**üìö Detalhes:** Ver `015-ds-tokens-architecture.mdc` para especifica√ß√£o completa
